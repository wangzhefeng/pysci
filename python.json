{
    // Place your snippets for python here. Each snippet is defined under a snippet name and has a prefix, body and 
    // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
    // same ids are connected.
    // Example:
    "insert_try": {
        "prefix": "trye:",
        "body": [
            "try:",
            "    $1",
            "except:",
            "    logging.error(f\"{model_name}\"+str(traceback.format_exc()))"
        ],
        "description": "insert log to use"
    },
    "insert_log": {
        "prefix": "loge",
        "body": [
            "logging.error(f\"{model_name} $1\")",
            "$2"
        ],
        "description": "insert log to use"
    },
    "HEADER": {
        "prefix": "header",
        "body": [
            "# -*- coding: utf-8 -*-",
            "\n",
            "\"\"\"",
            "@File          : $TM_FILENAME",
            "@Date          : $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE",
            "@Author        : Bairui Zhan",
            "@Contact       : bairui.zhan@yo-i.net",
            "@Version       : 0.1.$CURRENT_MONTH$CURRENT_DATE$CURRENT_HOUR",
            "@Description   : description",
            "@Requirement   : 相关模块版本需求(例如: numpy >= 2.1.0)",
            "\"\"\"",
        ],
        "description": "生成python文件注释"
    },
    "DEMO_PY": {
        "prefix": "demo_python",
        "body": [
            "# -*- coding: utf-8 -*-",
            "\n",
            "\"\"\"",
            "@File          : $TM_FILENAME",
            "@Date          : $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE",
            "@Author        : Bairui Zhan",
            "@Contact       : bairui.zhan@yo-i.net",
            "@Version       : 0.1.$CURRENT_MONTH$CURRENT_DATE$CURRENT_HOUR",
            "@Description   : description",
            "@Requirement   : 相关模块版本需求(例如: numpy >= 2.1.0)",
            "\"\"\"",
            "\n",
            "#python libraries",
            "#python库",
            "import os",
            "import sys",
            "\n",
            "# global variable",
            "#全局变量",
            "GLOBAL_VARIABLE = None",
            "\n",
            "def func():",
            "    pass",
            "\n",
            "class DemoClass:",
            "    \"\"\"",
            "    类说明文档",
            "    \"\"\"",
            "    _class_config_param = 100  # 类私有不变量",
            "\t",
            "    def __init__(self, id_):",
            "        self.id = id_",
            "        self.param_a = None  # 类公开变量",
            "        self._internal_param = None  # 类私有变量",
            "\t",
            "    def ClassDemoFunc(self):",
            "        \"\"\"",
            "        类普通方法",
            "        \"\"\"",
            "        pass",
            "\t",
            "    def _ClassPrivateFunc(self):",
            "        \"\"\"",
            "        类私有方法",
            "        \"\"\"",
            "        pass",
            "\n",
            "class _PrivateDemoClass:",
            "    \"\"\"",
            "    私有类",
            "    \"\"\"",
            "\t",
            "    def __init__(self):",
            "        pass",
            "\n",
            "\n",
            "# 测试代码 main 函数",
            "def main():",
            "    pass",
            "\n",
            "if __name__ == \"__main__\":",
            "    main()",
            "\n"
        ],
        "description": "生成python模板"
    },
    "SIMPLEMODEL": {
        "prefix": "simple_model",
        "body": [
            "# -*- coding: utf-8 -*-",
            "\n",
            "\"\"\"",
            "@File          : $TM_FILENAME",
            "@Date          : $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE",
            "@Author        : Bairui Zhan",
            "@Contact       : bairui.zhan@yo-i.net",
            "@Version       : 0.1.$CURRENT_MONTH$CURRENT_DATE$CURRENT_HOUR",
            "@Description   : description",
            "@Requirement   : 相关模块版本需求(例如: numpy >= 2.1.0)",
            "\"\"\"",
            "# digital-machine API",
            "from digital_machine import *",
            "from digital_machine.templates import simple",
            "from digital_machine.templates import templates as t",
            "from digital_machine.runtime.default.timestamps import _align_timestamp",
            "\n",
            "# tool library",
            "import pandas as pd",
            "import numpy as np ",
            "import traceback",
            "import logging",
            "\n",
            "INPUT_METRIC_LIST = {",
            "    \"Domain_1\" : [",
            "        'input_metric_1',",
            "        'input_metric_2',",
            "        'input_metric_3',",
            "    ],",
            "    \"Domain_2\" : [",
            "        'input_metric_4',",
            "        'input_metric_5',",
            "        'input_metric_6',",
            "    ],",
            "}",
            "\n",
            "OUTPUT_CURRENT_METRIC_LIST = {",
            "    \"Domain_1\" : [",
            "        'output_metric_1',",
            "        'output_metric_2',",
            "        'output_metric_3',",
            "    ],",
            "    \"Domain_2\" : [",
            "        'output_metric_4',",
            "        'output_metric_5',",
            "        'output_metric_6',",
            "    ],",
            "}",
            "\n",
            "OUTPUT_PREDICTION_METRIC_LIST = {",
            "    \"Domain_1\": [",
            "        \"output_metric_7\",",
            "    ],",
            "    \"Domain_2\": [",
            "        \"output_metric_8\",",
            "    ],",
            "}",
            "\n",
            "ALL_NEED_OUTPUT_METRIC_LIST = list(",
            "    set(",
            "        [v for v in OUTPUT_CURRENT_METRIC_LIST.values()][0] + \\",
            "        [v for v in OUTPUT_PREDICTION_METRIC_LIST.values()][0]",
            "    )",
            ")",
            "\n",
            "\n",
            "input_features = {}",
            "input_features.update({",
            "    # Input features from the current object",
            "    param_name:{",
            "        \"metric\":\"%s.%s\" % (domain, param_name),",
            "        \"aggregation\": \"5s\",",
            "        \"aggregation-function\": \"avg\",",
            "        \"rolling\": \"10min\"\n",
            "    } for domain in INPUT_METRIC_LIST for param_name in INPUT_METRIC_LIST[domain]",
            "})",
            "\n",
            "\n",
            "output_features = {}",
            "output_features.update({",
            "    output_param: {",
            "        \"metric\":\"%s.%s\" % (domain, output_param),",
            "        \"series-length\": 120,",
            "        \"resolution\": \"5s\"\n",
            "    } for domain in OUTPUT_PREDICTION_METRIC_LIST for output_param in OUTPUT_PREDICTION_METRIC_LIST[domain]",
            "})",
            "\n",
            "output_features.update({",
            "    output_param: {",
            "        \"metric\":\"%s.%s\" % (domain, output_param),",
            "        \"aggregation\": \"5s\"\n",
            "    } for domain in OUTPUT_CURRENT_METRIC_LIST for output_param in OUTPUT_CURRENT_METRIC_LIST[domain]",
            "})",
            "\n",
            "\n",
            "# 缓存变量",
            "state_list = [",
            "    \"state_metric_1\", ",
            "    \"state_metric_2\",",
            "    \"last_information_timestamp_1\",",
            "    \"last_information_timestamp_2\",",
            "]",
            "\n",
            "# 策略消息",
            "INFO_PARAMS = [",
            "    \"information_1\",",
            "    \"information_2\",",
            "]",
            "\n",
            "# 策略消息发送时间间隔",
            "information_interval = 5 * 60",
            "\n",
            "class DeviceMachine(simple.SimpleClassTemplate):",
            "    \"\"\"\n",
            "    模型参数配置：输入、输出、调用、缓存、消息发送",
            "    需要修改的配置项：",
            "        - invocation_frequency",
            "        - id",
            "        - domain",
            "        - ",
            "    \"\"\"\n",
            "    logging.error(\"invoke class DeviceMachine\")",
            "    #定义模型调用频率，频率小于数据发送频率（5s）",
            "    @t.model(invocation_frequency = 4.8)",
            "\n",
            "    # 输入特征",
            "    @t.input(features = input_features)",
            "\n",
            "    # 输出特征",
            "    @t.output(features = output_features)",
            "\n",
            "    # 定义state变量，用于暂存中间计算数据不丢失，类似全局变量",
            "    @t.state(\"my_state\", state_list)",
            "\n",
            "    # 文本消息发送",
            "    @t.stateful_alert(",
            "        id = \"device_information\",",
            "        domain = \"project___DeviceInformation\",",
            "        schema = {",
            "            \"target_id\": { \"type\": t.STRING, \"index\": True },",
            "            \"timestamp\": { \"type\": t.NUMBER, \"index\": True },",
            "            \"information1\": t.STRING,",
            "            \"information2\": t.STRING,",
            "        }",
            "    )",
            "\n",
            "    # primary domain metric 获取",
            "    @t.attribute_input(attributes={",
            "    \"test_metric\": { \"field\": \"OpParam.test_metric\" },",
            "    },cache=60)",
            "\n",
            "    # primary domain metric 更新",
            "    @t.attribute_output(attributes={",
            "    \"test_metric\": { \"field\": \"OpParam.test_metric\" },",
            "    })",
            "\n",
            "    def device_model(self, instance, input, output, my_state, device_information, attribute_input, attribute_output):",
            "        ",
            "        TIMEZONE = \"Asia/Shanghai\"\n",
            "        timestamp = _align_timestamp(input.timestamp, TIMEZONE, resolution = \"5s\")",
            "        logging.error(\"Invoke device_model, align timestamp=%s, instance=%s\", timestamp, instance.device_key)",
            "\n",
            "        # state",
            "        state_dict = {k: my_state.get(k, default = 0) for k in state_list}",
            "        logging.error(\"original state dict=%s\", state_dict)",
            "\n",
            "        # input data",
            "        all_data = pd.DataFrame()",
            "        for feature_name, feature_value in input.data.items():",
            "            all_data = pd.concat([all_data, input.data[feature_name]], axis = 1)",
            "        all_data = all_data.fillna(method = \"ffill\")",
            "        all_data = all_data.fillna(method = \"bfill\")",
            "        ",
            "        # primary domain get",
            "        test_metric = attribute_input.data[\"test_metric\"]",
            "        logging.error(\"test_metric=%s, instance=%s\",",
            "                        test_metric, instance.device_key.split(\"|\")[-1])",
            "\n",
            "        # primary domain update",
            "        test_value = np.random.randint(1,100)",
            "        logging.error(\"sending primary domain test_metric %s\", test_value)",
            "        attribute_output.data[\"test_metric\"] = test_value",
            "\n",
            "        # run model",
            "        model_result, update_dict = main_model(",
            "            all_data,",
            "            timestamp,",
            "            instance.device_key.split(\"|\")[-1],",
            "            state_dict",
            "        )",
            "\n",
            "        # update state_dict",
            "        state_dict.update(update_dict)",
            "        logging.error(\"modified state dict=%s\", state_dict)",
            "        for k, v in state_dict.items():",
            "            my_state.set(k, v)",
            "\n",
            "        # 发送模型结果",
            "        # for ins in model_result.keys():",
            "        #     for key in model_result[ins]:",
            "        for key in model_result.keys():",
            "            if key in ALL_NEED_OUTPUT_METRIC_LIST:",
            "                output.data[key] = model_result[key]",
            "        logging.error(\"DeviceMachine output data=%s\", output.data)",
            "\n",
            "        # 发送策略消息",
            "        # 判断结果中information不为 \"-1\"的数量，之所以是\"-1\"是考虑到定义information的时候type为string",
            "        information_dict = dict([(key, model_result[key]) for key in INFO_PARAMS if key in model_result and model_result[key] != \"-1\"])",
            "        logging.error(\"information_dict=%s\", information_dict)",
            "        if len(information_dict) > 0:",
            "            device_information.raise_alert(",
            "                dict({",
            "                        \"target_id\": instance.device_key.split(\"|\")[-1],",
            "                        \"timestamp\": input.timestamp,",
            "                    }, ",
            "                    **dict([(key, model_result[key]) for key in INFO_PARAMS if key in model_result and model_result[key] is not None]))",
            "            )",
            "\n",
            "\n",
            "def sub_model_1(target_id, timestamp, all_data, state):",
            "    \"\"\"\n",
            "    子模型1",
            "    \"\"\"\n",
            "    output_metric_1 = 0",
            "\n",
            "    state[\"state_metric_1\"] = 0",
            "\n",
            "    return {",
            "        \"output_metric_1\": output_metric_1",
            "    }, state",
            "\n",
            "def sub_model_2(target_id, timestamp, all_data, state): ",
            "    \"\"\"\n",
            "    子模型2",
            "    \"\"\"\n",
            "    output_metric_2 = 0",
            "    output_metric_3 = 0",
            "\n",
            "    state[\"state_metric_2\"] = 0",
            "\n",
            "    return {",
            "        'output_metric_2':output_metric_2,",
            "        'output_metric_3':output_metric_3",
            "    }, state",
            "\n",
            "\n",
            "def generate_information(target_id, timestamp, all_data, state):",
            "    \"\"\"\n",
            "    生成消息",
            "    \"\"\"\n",
            "    return {",
            "        \"information1\": \"test_information1\",",
            "        \"information2\": \"test_information2\",",
            "    }",
            "\n",
            "\n",
            "def main_model(all_data, timestamp, target_id, state):",
            "    '''",
            "    Collect all outputs of sub models",
            "    '''",
            "    device_result = {}",
            "    device_result[\"timestamp\"] = timestamp",
            "    device_result[\"target_id\"] = target_id",
            "\n",
            "    try:",
            "        result_1, state = sub_model_1(target_id, timestamp, all_data, state)",
            "    except:",
            "        result_1 = {}",
            "        traceback.print_exc()",
            "    device_result.update(result_1)",
            "\n",
            "    try:",
            "        result_2, state = sub_model_2(target_id, timestamp, all_data, state)",
            "    except:",
            "        result_2 = {}",
            "        traceback.print_exc()",
            "    device_result.update(result_2)",
            "\n",
            "    try:",
            "        information_result = generate_information(target_id, timestamp, all_data, state)",
            "    except:",
            "        information_result = {",
            "            \"information_1\": \"-1\",",
            "            \"information_2\": \"-1\",",
            "        }",
            "        traceback.print_exc()",
            "    device_result.update(information_result)",
            "\n",
            "    #TODO",
            "    for info in INFO_PARAMS:",
            "        if device_result[info] != \"-1\":",
            "            if timestamp - state[\"last_information_timestamp_\" + info.split(\"_\")[-1]] < information_interval:",
            "                device_result[info] = \"-1\"\n",
            "            else:",
            "                state[\"last_information_timestamp_\" + + info.split(\"_\")[-1]] = timestamp",
            "\n",
            "    logging.error(\"device_model result = %s\", device_result)",
            "\n",
            "    return device_result, state",
            
        ],
        "description": "生成python模板"
    },
    "TASKMODEL": {
        "prefix": "task_model",
        "body": [
            "# -*- coding: utf-8 -*-",
            "\n",
            "\"\"\"",
            "@File          : $TM_FILENAME",
            "@Date          : $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE",
            "@Author        : Bairui Zhan",
            "@Contact       : bairui.zhan@yo-i.net",
            "@Version       : 0.1.$CURRENT_MONTH$CURRENT_DATE$CURRENT_HOUR",
            "@Description   : description",
            "@Requirement   : 相关模块版本需求(例如: numpy >= 2.1.0)",
            "\"\"\"",
            "# digital-machine batch task API",
            "from digital_machine import filter_classes, digital_twin_model",
            "from digital_machine.models import Model",
            "from digital_machine.batch import *",
            "from digital_machine.runtime.default.timestamps import _align_timestamp",
            "\n",
            "# Tool Library",
            "import time",
            "import datetime",
            "import itertools",
            "import numpy as np",
            "import pandas as pd",
            "import traceback",
            "import logging",
            "import pytz",
            "\n",
            "# Data API",
            "from .utils.query_write_api import *",
            "\n",
            "# option config",
            "pd.set_option('float_format', lambda x: '%.1f' % x)",
            "\n",
            "\n",
            "def write_timeseries_result(batch_context, class_, result_dict, hash_dict, hash_resolution):",
            "    for instance in batch_context.find_instances(class_):",
            "        instance_key = instance.key.split(\"|\")[-1]",
            "        logging.error(\"Instance String: %s\", instance_key)",
            "\n",
            "        TIMESTAMP = result_dict[instance_key]['timestamp']",
            "        for key, value in result_dict[instance_key].items():",
            "            if key != 'timestamp':",
            "                # logging.error(\"write key:%s, value:%s\", key, value)",
            "                if isinstance(value, (np.int64, int, float)):",
            "                    data = pd.DataFrame(data = [value],",
            "                                        index = [TIMESTAMP],",
            "                                        columns = [key])",
            "                    instance.write_timeseries(metric = MetricName.parse(hash_dict[key]),",
            "                                              resolution = hash_resolution[key],",
            "                                              values = data,",
            "                                              avg = key)",
            "                    # logging.error(\"write current timeseries data of %s\", instance.key)",
            "                else:",
            "                    instance.write_timeseries(metric = MetricName.parse(hash_dict[key]),",
            "                                              resolution = hash_resolution[key],",
            "                                              values = value,",
            "                                              avg = key)",
            "                    # logging.error(\"write predicted timeseries data of %s\", instance.key)",
            "\n",
            "\n",
            "def query_primary_metric_v2(batch_context, class_, domain):",
            "    \"\"\"\n",
            "    batch_context, class_, domain, new_value_dict",
            "    \"\"\"\n",
            "    instance_dict = {}",
            "    for instance in batch_context.find_instances(class_):",
            "        instance_key = instance.key.split(\"|\")[-1]",
            "        get_domain_value = instance.get_domain(domain = domain)",
            "        instance_dict[instance_key] = {domain : get_domain_value}",
            "    logging.error(\"get_domain have new metric value in MongoDB, metric list: %s\", instance_dict)",
            "\n",
            "    return instance_dict",
            "\n",
            "\n",
            "def query_timeseries_data_v2(batch_context, class_, metric_list, domain, resolution, timestamp, interval_from, interval_to, aggregation):",
            "    temp_dict = {}",
            "    for instance in batch_context.find_instances(class_):",
            "        instance_key = instance.key.split('|')[-1]",
            "        temp_dict[instance_key] = pd.DataFrame()",
            "        for metric in metric_list:",
            "            try:",
            "                metric_df = instance.query_timeseries(",
            "                    metric = MetricName.parse(\"%s.%s\" % (domain, metric)),",
            "                    resolution = resolution,",
            "                    _from = timestamp - interval_from,",
            "                    _to = timestamp - interval_to,",
            "                    aggregation = aggregation,",
            "                    column = metric",
            "                )",
            "                # logging.error(\"query_write_api %s query result=%s\", metric, metric_df)",
            "                temp_dict[instance_key] = pd.concat([temp_dict[instance_key],metric_df], axis = 1)",
            "            except:",
            "                logging.error(\"query_write_api Can't query %s data\", metric)",
            "                temp_dict[instance_key][metric] = np.nan",
            "                traceback.print_exc()",
            "    return temp_dict",
            "\n",
            "def write_timeseries_result(batch_context, class_, result_dict):",
            "    for instance in batch_context.find_instances(class_):",
            "        instance_key = instance.key.split(\"|\")[-1]",
            "        # logging.error(\"Instance String: %s\", instance_key)",
            "        if instance_key in result_dict:",
            "            if 'timestamp' in result_dict[instance_key] :",
            "                TIMESTAMP = result_dict[instance_key]['timestamp']",
            "            for metric_key, metric_value in result_dict[instance_key].items():",
            "\n",
            "                if metric_key != 'timestamp':",
            "\n",
            "                    if len(metric_key.split(\".\")) != 2:",
            "                        logging.error(\"metric_key should be Domain.Metric\")",
            "                        continue",
            "                    # logging.error(\"write metric: %s, instance: %s\", metric_key, instance.key)",
            "                    if isinstance(metric_value[\"value\"], (np.int64, int, float)):",
            "                        if metric_value[\"value\"] != -1:",
            "                            try:",
            "                                data = pd.DataFrame(data = [metric_value[\"value\"]],",
            "                                                    index = [TIMESTAMP],",
            "                                                    columns = [metric_key.split('.')[-1]])",
            "                                instance.write_timeseries(metric = MetricName.parse(metric_key),",
            "                                                        resolution = metric_value[\"resolution\"],",
            "                                                        values = data)",
            "                                # logging.error(\"write current timeseries data, metric: %s, instance: %s\", metric_key, instance.key)",
            "                            except:",
            "                                logging.error(\"write current timeseries data failed, instance: %s\", instance_key)",
            "                    else:",
            "                        if len(metric_value[\"value\"]) > 0:",
            "                            try:",
            "                                instance.write_timeseries(metric = MetricName.parse(metric_key),",
            "                                                        resolution = metric_value[\"resolution\"],",
            "                                                        values = metric_value[\"value\"])",
            "                                # logging.error(\"write predicted timeseries data, metric: %s, instance: %s\", metric_key, instance.key)",
            "                            except:",
            "                                logging.error(\"write predicted timeseries data failed, instance: %s\", instance_key)",
            "                        else:",
            "                            logging.error(\"can't write empty dataframe, metric: %s, instance: %s\", metric_key, instance.key)",
            "\n",
            "\n",
            "def MODEL(inputs):",
            "    instance_class_1_result = {",
            "        \"domain_1\":{",
            "            \"metric_1\":1,",
            "            \"metric_2\":2",
            "    }}",
            "\n",
            "    return instance_class_1_result",
            "\n",
            "\n",
            "def MODEL_2(inputs):",
            "    instance_class_1_result = {",
            "        \"class_1_instance_1\":{",
            "        \"domain_1\":{",
            "            \"metric_1\":1,",
            "            \"metric_2\":2",
            "            }",
            "        },",
            "        \"class_1_instance_2\":{",
            "        \"domain_1\":{",
            "            \"metric_1\":1,",
            "            \"metric_2\":2",
            "            }",
            "        }",
            "    }",
            "    instance_class_2_result = {",
            "        \"class_2_instance_1\":{",
            "        \"domain_2\":{",
            "            \"metric_3\":3,",
            "            \"metric_4\":4",
            "            }",
            "        },",
            "        \"class_2_instance_2\":{",
            "        \"domain_2\":{",
            "            \"metric_3\":3,",
            "            \"metric_4\":4",
            "            }",
            "        }",
            "    }",
            "    return instance_class_1_result, instance_class_2_result",
            "\n",
            "\n",
            "\n",
            "\n",
            "TIMEZONE = \"Asia/Shanghai\"\n",
            "\n",
            "def run():",
            "    B = BatchContext.get()",
            "\n",
            "    logging.warning(\"Job {} of task {} invoked at {}\".format(",
            "        B.job,",
            "        B.task,",
            "        B.job_config.invocation_timestamp",
            "    ))",
            "    # ====================================================================",
            "    # job timestamp",
            "    # ====================================================================",
            "    # Task 启动时间戳",
            "    now = B.job_config.invocation_timestamp",
            "    logging.error(f\"Task invoke timestamp in task_0:{now}\")",
            "\n",
            "    # state存储，get('counter', 0) 表示从state中获取key为'counter'的值，如果没有则默认为0",
            "    counter = B.state.get('counter', 0)",
            "    logging.error(\"original counter=%s\", counter)",
            "    ",
            "    B.state['counter'] = counter + 1",
            "    logging.error(\"counter=%s\", B.state.get('counter', 0))",
            "\n",
            "\n",
            "    # 日期时间本地转换",
            "    local_tz = pytz.timezone(TIMEZONE)",
            "    local_current = datetime.datetime.utcfromtimestamp(int(now)).replace(tzinfo = pytz.utc).astimezone(local_tz)",
            "    current_day = local_current.day",
            "    current_hour = local_current.hour",
            "    current_minute = local_current.minute",
            "    current_second = local_current.second",
            "    logging.error(f\"Task current_day:{current_day}\")",
            "    logging.error(f\"Task current_hour:{current_hour}\")",
            "    logging.error(f\"Task current_minute:{current_minute}\")",
            "    logging.error(f\"Task current_second:{current_second}\")",
            "    # ====================================================================",
            "    # class",
            "    # ====================================================================",
            "    Project_name = \"CaoJing\" #针对不同project做修改",
            "    instance_class_1 = digital_twin_model(f\"{Project_name}\", \"instance_class_1\")",
            "    instance_class_2 = digital_twin_model(f\"{Project_name}\", \"instance_class_2\")",
            "\n",
            "    instance_class_1_domain_3_data = query_timeseries_data_v2(B, instance_class_1, [\"metric_5\",\"metric_6\"], \"domain_3\", \"1min\", now, 305, -5, BatchContext.AVG)",
            "    instance_class_2_domain_4_data = query_timeseries_data_v2(B, instance_class_2, [\"metric_5\",\"metric_6\"], \"domain_4\", \"1min\", now, 305, -5, BatchContext.AVG)",
            "    \"\"\"\n",
            "    使用时通过 instance_class_1_domain_3_data[instance_key][metirc_5] 取到DataFrame列",
            "    \"\"\"\n",
            "    # 获取 operational Domain",
            "    \"\"\"\n",
            "    针对每个instance_class_1 运行primary domain模型",
            "    \"\"\"\n",
            "    for instance in B.find_instances(instance_class_1):",
            "        instance_key = instance.key.split(\"|\")[-1]",
            "        instance_class_1_domain_1 = instance.get_domain(domain = \"domain_1\") #读取 primary domain",
            "        try:",
            "            instance_class_1_result =  MODEL(instance_class_1[\"metric_1\"]) # 运行模型",
            "            # 更新EPollution primary metric",
            "            instance_class_1_domain_1.update(instance_class_1_result['domain_1']) # 将模型结果更新至primary domain",
            "            logging.error(f\"model has been invoked\")",
            "        except:",
            "            traceback.print_exc()",
            "            logging.error(f\"model failed\")",
            "        instance.set_domain(\"domain_1\",instance_class_1_domain_1)",
            "        final_instance_class_1_domain_1 = instance.get_domain(domain = \"domain_1\")",
            "        logging.error(f\"afterE MODEL:{instance_key},instance_class_1_domain_1{final_instance_class_1_domain_1}\")",
            "\n",
            "    ",
            "    \"\"\"\n",
            "    针对系统运行模型",
            "    \"\"\"\n",
            "    whole_primary_metrics = {}",
            "    whole_primary_metrics.update(query_primary_metric_v2(B, instance_class_1, \"domain_1\"))",
            "    whole_primary_metrics.update(query_primary_metric_v2(B, instance_class_2, \"domain_2\"))",
            "    logging.error(f\"whole_primary_metrics:{whole_primary_metrics}\")",
            "    try:",
            "        class_1_result,class_2_result = MODEL_2(whole_primary_metrics[\"class_1_instance_1\"][\"domain_1\"][\"metric_1\"],",
            "                                whole_primary_metrics[\"class_1_instance_2\"][\"domain_1\"][\"metric_1\"], ",
            "                                whole_primary_metrics[\"class_2_instance_1\"][\"domain_2\"][\"metric_3\"], ",
            "                                whole_primary_metrics[\"class_2_instance_2\"][\"domain_2\"][\"metric_4\"])",
            "\n",
            "        for instance in B.find_instances(instance_class_1):",
            "            instance_key = instance.key.split(\"|\")[-1]",
            "            class_1_instance = instance.get_domain(domain = \"domain_1\")",
            "            # 读取domain",
            "            class_1_instance.update(class_1_result[instance_key])",
            "            instance.set_domain(\"domain_1\",class_1_instance)",
            "            # set domain",
            "            final_class_1_instance = instance.get_domain(domain = \"domain_1\")",
            "            # check domain",
            "            logging.error(f\" invoke MODEL_2:{instance_key},domain_1:{final_class_1_instance}\")",
            "            time.sleep(1)",
            "        for instance in B.find_instances(instance_class_2):",
            "            instance_key = instance.key.split(\"|\")[-1]",
            "            # 读取domain",
            "            class_2_instance = instance.get_domain(domain = \"domain_2\")",
            "            # set domain",
            "            class_2_instance.update(class_2_result[instance_key])",
            "            instance.set_domain(\"domain_2\",class_2_instance)",
            "            final_class_2_instance = instance.get_domain(domain = \"domain_2\")",
            "            # check domain",
            "            logging.error(f\"invoke MODEL_2 :{instance_key},domain_2:{final_class_2_instance}\")",
            "\n",
            "    except:",
            "        logging.error(f\" invoke MODEL_2 failed\")",
            "    instance_class_1_timeseries_data ={",
            "            \"instance_class_1_instance_1\": {",
            "                \"timestamp\": now,",
            "                \"Domain.metric_1\": {",
            "                    \"resolution\":\"1min\",",
            "                    \"value\": 1,",
            "                },",
            "                \"Domain.metric_2\":{",
            "                    \"resolution\": \"1min\",",
            "                    \"value\":2,",
            "                    },",
            "            },",
            "            \"instance_class_1_instance_2\": {",
            "                \"timestamp\": now,",
            "                \"Domain.metric_1\": {",
            "                    \"resolution\": \"1min\",",
            "                    \"value\": 3,",
            "                },",
            "                \"Domain.metric_2\": {",
            "                    \"resolution\": \"1min\",",
            "                    \"value\": 4,",
            "                },",
            "            },",
            "        }",
            "    try:",
            "        write_timeseries_result(B, instance_class_1, instance_class_1_timeseries_data)",
            "        logging.error(f\"write values done\")",
            "    except:",
            "        logging.error(f\"write values failed\")",
            "    ",
        ],
        "description": "生成python文件注释"
    },
    "CLASSMODEL": {
        "prefix": "class_model",
        "body": [
            "class CLASSMODEL:",
            "    \"\"\"",
            "    锅炉车间",
            "    \"\"\"",
            "    def __init__(self,parameter_1,parameter_2):",
            "        \"\"\"[锅炉车间初始化模型]",
            "        Parameters",
            "        ----------",
            "        parameter_1 : [string]",
            "            [字符串]",
            "        parameter_2 : [int]",
            "            [编号]",
            "        \"\"\"",
            "        self.parameter_1 = parameter_1  ",
            "        self.parameter_2 = parameter_2  ",
        ],
        "description": "生成类模型函数"
    },
}