
Python 多线程
=======================



1.程序、进程、线程、并发、并行、高并发
------------------------------------------

    - `知乎解释 <https://www.zhihu.com/question/307100151/answer/894486042>`_ 

    - `简单解释 <http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html>`_ 

1.1 进程(Process)
~~~~~~~~~~~~~~~~~~~~~~~

1.1.1 传统意义的进程
^^^^^^^^^^^^^^^^^^^^^^^

.. note:: wiki 进程解释：
    
    - In computing, a process is the instance of a computer program that is being executed by one or many threads.

假如你想做一件事情，为了解决这个问题，你先构想出来假如你自己一个人做，整个过程第一步干什么，第二步干什么等等。
这个干活的过程，可以被称作一个 **进程(Process)**。或者你可以理解为 “一个做事的办法/步骤/方案”。

进程的英文 Process 本意就是 “过程” 的意思，是一个抽象的概念。这个活有没有真的干不重要，重要的是你已经预先想好了
这个活该怎么干，有了一个可行的思路。

.. note::

    这里 **进程** 仅仅是描述这个方案的，至于这个方案是在脑海里，还是已经被执行了，是不重要的。

1.1.2 程序进程
^^^^^^^^^^^^^^^^^^^^^^^

程序中的进程概念是指“程序在操作系统中运行的实例”。所谓 “实例” 是指同一个程序可以同时在操作系统里实际的运行。

为了避免混淆，我在下文中将操作系统的这个进程概念称为 **OS进程**。而对上一节里面讲的“想办法”的进程称为**P进程**。

    - **OS进程** 到底怎么实现呢？铺路的工作真的开干时，要不断记录买了什么料，已经花了多少钱，哪一块已经铺好了，
      哪一块刚铺完沥青得晾着等等。这些信息只有工作真的开干才会有。**OS进程** 也是一样，因此比如 Linux 将进程实现为 
      “task_struct"，里面记录了CPU要完成这个工作的一整套数据。比如一个事情A，CPU没做完，被程序员要求做另外
      一件事情B。就得找个地方记录做了一半的A的那些数据，以便于 CPU 回过头来再做A时能够继续。再次强调下，
      **P进程** 和 **OS进程** 并不是一个意思，尽管会有一些关联。所以在阅读各种资料时一定要根据上下文分清楚进程到
      底是什么意思。总结如下：

        - **P进程** 指的是如何想明白做一件事情的过程。他用来帮助你理清做事的思路。这个事情做与没做，
          对于 **P进程** 这个概念不重要

        - **OS进程** 是指程序真的运行起来的实例，可以被实现为存放调度给CPU的任务和状态的数据结构

1.2 程序
~~~~~~~~~~~~~~~~~

把上面的 “一个做事的办法/步骤/方案” 用纸写出来就得到了一个 **程序**，在软件中也是如此。

1.3 线程(Threading)
~~~~~~~~~~~~~~~~~~~~~~~

1.3.1 线程
^^^^^^^^^^^^^^^^^^^^^^^

.. note:: wiki 进程解释：
    
    - In computing, a process is the instance of a computer program that is being executed by one or many threads.

上面 wiki 对进程的定义指出一个 **OS进程** 是由一个到多个 **线程** 组成。这里的 **线程(Thread)** 是一个抽象概念。

但在Linux中，线程是被实现为“轻量级进程”的。也就是说在Linux中的进程和线程实现的本质是一样的。
只不过在以下2点上有显著区别：

    - 在资源消耗上进程的消耗多，线程消耗相对少，以及；
    
    - 内存空间上有一些不同：进程的虚拟内存彼此隔离，而线程则共享同一虚拟内存空间有些不同。

但Linux中 OS进程和线程都用作任务调度单位。因此，Linux这种实现方式和理论上的概念不是很吻合，
但是大量的程序已经跑在这个模式上了。而且大家早就已经习惯了。其他操作系统对 OS进程和线程的实现会有所不同。
如果碰到了不要惊讶。

1.3.2 多线程
^^^^^^^^^^^^^^^^^^^^^^^

多线程类似于同时执行多个不同程序

- 多线程运行有如下优点：

    - 使用线程可以把占据长时间的程序中的任务放到后台去处理
    
    - 用户界面可以更加吸引人。比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度。
      程序的运行速度可能加快
    
    - 在一些等待的任务实现上如用户输入、文件读写和网络收发数据等，线程就比较有用了。在这种情况下我们可以释放
      一些珍贵的资源如内存占用等等

- 线程运行原理

    - 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，
      由应用程序提供多个线程执行控制。

    - 每个线程都有他自己的一组 CPU 寄存器，称为线程的上下文，该上下文反映了线程上次运行该线程的 CPU 寄存器的状态。

    - **指令指针** 和 **堆栈指针寄存器** 是线程上下文中两个最重要的寄存器，线程总是在进程得到上下文中运行的，
      这些地址都用于标志拥有线程的进程地址空间中的内存。

        - 线程可以被抢占(中断)
        - 在其他线程正在运行时，线程可以暂时搁置(也称为睡眠), 这就是线程的退让

线程可以分为:

    - 内核线程：由操作系统内核创建和撤销

    - 用户线程：不需要内核支持而在用户程序中实现的线程


1.4 并发
~~~~~~~~~~~~~~~~~

【并发】（Concurrency）是由【P进程】引申出来的抽象概念。

上面说到了你可以假设自己一个人按照一定的步骤来铺路，一个人从头干到尾，这是一个“串行”的【P进程】。

但你也可以假设有2个人铺路。比如你可以按照长度分两半，一人铺500m * 50m；也可以按宽度划分，一人铺1000m * 25m；你还可以说让一个人负责铺全部路面的前5个步骤，另外一个人负责铺路面的余下5个步骤。然后你可以进一步想，假如不是雇2个人，而是雇20个人概如何分工呢？你可以混搭按长度，宽度，步骤等各种方式进行拆分。你甚至可以考虑这20个人不是完全一样的，有的能力强，有的能力弱，可以适当的调整工作量的比例等等。

不管怎样拆，都意味着你得到了【并发】的【P进程】。换成说人话就是，你有一套方案，可以让多个人一起把事情做的更高效。注意是“可以“让事情更高效，而不是“必然“让事情更高效。是不是更高效要看到底是怎么执行的，后边会讲。

举个写代码的例子，你有一个很长很长的数组，目标是把每一个数都*2。一个并发的做法就是把数组拆为很多个小段，然后每个小段的元素依次自己*2。这样的程序写出来就是一个【并发】的【程序】。这个程序如果运行起来就是【并发】的【OS进程】。

这时就会出现一个问题，当你想把一个【并发】的【P进程】写成程序时，你怎么用编程语言告诉操作系统你的程序的一些步骤是【并发】的。更确切地说，你需要一个写法（可能是语法，也可能是函数库）表达：

    - 几个任务是【并发】的

    - 【并发】的任务之间是怎么交互协作的

为了解决这两个问题，人们总结了一些方法，并将其称为“并发模型”。比如：

    - Fork & Join模型（大任务拆解为小任务并发的跑，结果再拼起来）

    - Actor模型（干活的步骤之间直接发消息）

    - CSP模型（干活的步骤之间订阅通话的频道来协作）

    - 线程&锁模型（干活的人共享一个小本本，用来协作。注意小本本不能改乱套了，所以得加锁）

    - …… 

以Java中的线程为例，大家想表达【并发】就启动新的Thread（或者某种等价操作，如利用线程池）；想让Thread之间交互，就要依靠共享内容。但是【并发】的Thread如果同时修改同一份数据就有可能出错（被称为竞争问题），为了解决这个问题就要引入锁（Lock，或者一些高级的同步工具，如CountdownLatch，Semaphore）。

特别强调下，Java的线程是表达并发的概念的类。这个类在绝大部分操作系统上使用操作系统内核中的【线程】实现。二者之间还是有一些细微的差异。即用开发者用Java Thread写代码表达思路，和操作系统调度线程执行是两个层面的事情。请努力认识到这一点。

再比如Erlang是基于Actor的并发模型（其实这是原教旨主义的OO）。那么就是每个参与【并发】的任务称为Process（又一个进程……，和【P进程】以及【OS进程都不太一样】，叫【E进程】好了，Erlang中的"进程“）。【E进程】之间通过消息来协作。每个【E进程】要不是在处理消息，要不就是在等新的消息。

如果你用go，那么表达并发的工具就是goroutine，goroutine之间协作要用channel。（当然也可以用Sync包加锁，不展开）。

对于并发模型《7周7并发模型》这本书讲的非常好。推荐阅读。书中展示了七种最经典的并发模型和大量的编码实例。

1.5 并行
~~~~~~~~~~~~~~~~~

现在我们已经有了一个【并发】的想法，然后进入执行层面。

回到上面铺路的例子，你虽然假设有20个人可以一起干活。但你不一定真的能雇得到20个人。假如说你实际上最终只雇到1个人。
但你有一个为20个人一起干活设计的方法。能不能用呢？当然能，只要让这个人先干第1人份的活，再干第2人份的……

但如果你真的雇了10个人，就可以很容易的让第1个人干第1人份和第2人份的活，第2个人干第3和第4人份的活…… 
而这10个人同时在工地上干活，就是【并行】（Parallelism）。

在软件系统中，【程序】是否能【并行】运行，要看物理上有多少个CPU核心可以同时干活（或者再扩展一下，
有多少台可用的物理主机）。

比如你写了个Java程序，同时启动了4个线程，但CPU只有单核，那么同一时刻只有一个线程在运行。
如果有4个CPU核心，那么可以做到4个线程完全【并行】运行。如果有2个核心，那么就处于一种中间态。
比如你可以用“并发度=4“，”并行度=2“形容这种情况。



1.6 高并发
~~~~~~~~~~~~~~~~~


2.Python 线程、线程模块
------------------------

Python 中使用线程有两种方式：

    - 函数

    - 用类来包装线程对象

Python3 线程中常用的两个模块为：

    - ``_thread``

        - ``_thread`` 模块提供了低级别的、原始的线程以及一个简单的锁，它相比 ``threading`` 模块的功能还是比较有限的。

    - ``threading`` (推荐使用)

        - ``threading`` 模块除了包含 ``_thread`` 模块中的所有方法之外，还提供了其他方法：

            - ``threading.currentThread()``: 返回当前的线程变量

            - ``threading.enumerate()``: 返回一个包含正在运行的线程的 list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程

            - ``threading.activeCount()``: 返回正在运行的线程数量，与 ``len(threading.enumerate())`` 有相同的结果
    
    - ``Thread`` 类

        - run(): 用以表示线程活动的方法
        - start(): 启动线程活动
        - join(): 等待至线程终止。这阻塞调用线程直至线程的 join() 方法被调用终止、正常退出或者抛出未处理的异常，或者是可选的超时发生
        - isAlive(): 返回线程是否是活动的
        - getName(): 返回线程名
        - setName(): 设置线程名


.. note:: 

    ``thread`` 模块已被废弃。用户可以使用 ``threading`` 模块代替。所以，在 Python3 中不能再使用 ``thread`` 模块。
    为了兼容性，Python3 将 ``thread`` 重命名为 "_thread"。


2.1 函数式: _thread
~~~~~~~~~~~~~~~~~~~~~~~~~~

函数式：调用 ``_thread`` 模块中的 ``start_new_thread`` 函数来产生线程

- 语法

    .. code-block:: 
        
        _thread.start_new_thread(function, args[, kwargs])

    - 其中:

        - ``function``: 线程函数

        - ``args``: 传递给线程函数的参数，必须是个 tuble 类型

        - ``kwargs``: 可选参数

- 示例(ctrl-c 退出)

    .. code-block:: python
    
        #!/usr/bin/python3

        import _thread
        import time

        # 为线程定义一个函数
        def print_time(threadName, delay):
            count = 0
            while count < 5:
                time.sleep(delay)
                count += 1
                print("%s: %s" % (threadName, time.ctime(time.time())))
            
        # 创建两个线程
        try:
            _thread.start_new_thread(print_time, ("Thread-1", 2))
            _thread.start_new_thread(print_time, ("Thread-2", 4))
        except:
            print("Error: 无法启动线程")
        
        while 1:
            pass

执行结果如下：

.. code-block:: 

    Thread-1: Wed Apr  6 11:36:31 2016
    Thread-1: Wed Apr  6 11:36:33 2016
    Thread-2: Wed Apr  6 11:36:33 2016
    Thread-1: Wed Apr  6 11:36:35 2016
    Thread-1: Wed Apr  6 11:36:37 2016
    Thread-2: Wed Apr  6 11:36:37 2016
    Thread-1: Wed Apr  6 11:36:39 2016
    Thread-2: Wed Apr  6 11:36:41 2016
    Thread-2: Wed Apr  6 11:36:45 2016
    Thread-2: Wed Apr  6 11:36:49 2016



2.2 
~~~~~~~~~~~~~~~~~~~~~~~~~~












3.创建 Python 线程
------------------------



4.线程同步
------------------------



5.线程优先级队列(Queue)
------------------------


6.Python 多进程 multiprocessing 模块
------------------------------------------------

在使用multiprocessing库实现多进程之前，我们先来了解一下操作系统相关的知识。

- Unix/Linux实现多进程

    - Unix/Linux操作系统提供了一个 ``fork()`` 系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，
      但是 ``fork()`` 调用一次，返回两次，因为操作系统自动把当前父进程复制了一份子进程，然后，
      分别在父进程和子进程内返回。

    - 子进程永远返回 0，而父进程返回子进程的 ID。这样，一个父进程可以 fork 出很多子进程，所以，
      父进程要记下每个子进程的 ID，而子进程只需要调用 ``getppid()`` 就可以拿到父进程的 ID。

    - Python 的 ``os`` 模块封装了常见的系统调用，其中就包括 ``fork``，可以在 Python 程序中轻松创建子进程.

- Windows的多进程
    
    - 由于Windows没有 fork 调用，而如果我们需要在 Windows 上用 Python 编写多进程的程序。
      我们就需要使用到 ``multiprocessing`` 模块。


.. code-block:: python

    from multiprocessing import Pool

    pool = Pool(cpu)
    for i in iters:
        pass
    pool.close()
    pool.join()

6.1 multiprocessing -- 基于进程的并行
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

6.1.1 概述
^^^^^^^^^^^^^^

multiprocessing 是一个支持使用与 threading 模块类似的 API 来产生进程的包。 
multiprocessing 包同时提供了本地和远程并发操作，通过使用子进程而非线程有效地绕过了 全局解释器锁。 
因此，multiprocessing 模块允许程序员充分利用给定机器上的多个处理器。 
它在 Unix 和 Windows 上均可运行。

multiprocessing 模块还引入了在 threading 模块中没有的API。一个主要的例子就是 Pool 对象，
它提供了一种快捷的方法，赋予函数并行化处理一系列输入值的能力，可以将输入数据分配给不同进程处理（数据并行）。
下面的例子演示了在模块中定义此类函数的常见做法，以便子进程可以成功导入该模块。这个数据并行的基本例子使用了 Pool ，

.. code-block:: python

    >>> from multiprocessing import Pool
    >>> def f(x):
    ...     return x * x
    
    >>> if __name__ == "__main__":
    ...     with Pool(5) as p:
    ...         print(p.map(f, [1, 2, 3]))
    >>> [1, 4, 9]

6.1.2 Process 类
^^^^^^^^^^^^^^^^^^^^

在 ``multiprocessing`` 中，通过创建一个 Process 对象然后调用它的 ``start()`` 方法来生成进程。Process 和 threading.Thread API 
相同。一个简单的多进程程序示例是：

.. code-block:: python

    from multiprocessing import Process

    def f(name):
        print("hello", name)
    
    if __name__ == "__main__":
        p = Process(target = f, args = ("bob",))
        p.start()
        p.join()

要显示所涉及的各个进程 ID, 这是一个扩展示例：

.. code-block:: python

    from multiprocessing import Process
    import os

    def info(title):
        print(title)
        print("module name:", __name__)
        print("parent process:", os.getppid())
        print("process id:", os.getpid())
    
    def f(name):
        info("function f")
        print("hello", name)
    
    if __name__ == "__main__":
        info("main line")
        p = Process(target = f, args = ("bob",))
        p.start()
        p.join()
