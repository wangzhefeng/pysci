
Python 装饰器
=============

.. code:: python

   #!/usr/bin/env python
   # -*- coding: utf-8 -*-

   from functools import wraps

   def logit(func):
   	@wraps(func)
   	def with_logging(*args, **kwargs):
   		print(func.__name__ + "was called!")
   		return func(*args, **kwargs)
   	return with_logging

   @logit
   def addition_func(x):
   	"""Do some math."""
   	return x + x


   result = addition_func(4)
   print(result)



1.什么是装饰器
-------------------

**装饰** 是为函数和类指定管理代码的一种方式。装饰器本身的形式是处理其它的可调用对象的可调用对象(如函数)。

Python 装饰器以两种相关的形式呈现：

   - **函数装饰器**

      - 在函数定义的时候进行名称重绑定，提供一个逻辑层来管理函数和方法或随后对它们的调用

   - **类装饰器**

      - 在类定义的时候进行名称重绑定，提供一个逻辑层来管理函数和方法或随后对它们的调用

简而言之，装饰器提供了一种方法，在函数和类定义的语句的末尾插入自动运行代码——对于函数装饰器，
在 def 的末尾；对于类装饰器，在 class 的末尾。这样的代码可以扮演不同的角色。


1.1 为什么使用装饰器
~~~~~~~~~~~~~~~~~~~~~~~~

装饰器的优点：

   - 装饰器为下面这样的任务提供了一种显示的语法，它使得意图明确，可以最小化扩展代码的冗余，并且有助于确保正确的 API 使用：

      - 装饰器有一种非常明确的语法，这使得它们比那些可能任意地远离主体函数或类的辅助函数调用更容易被人们发现 

      - 当主体函数或类定义的时候，装饰器应用一次；在对类或函数的每次调用的时候，不必添加额外的代码(在未来可能必须改变)

      - 由于前面的两点，装饰器使得一个 API 的用户不太可能忘记根据 API 需求扩展一个函数或类

   - 换句话说，除了其技术模型之外，装饰器提供了一些和代码维护性和审美相关的优点。此外，作为结构化工具，装饰器自然地促进了代码的封装，这减少了冗余性并使得未来变得更容易。

装饰器的缺点：

   - 当装饰器插入包装类的逻辑，它们可以修改装饰的对象的类型，并且它们可能引发额外的调用

   - 另外，同样的考虑也适用于任何为对象添加包装逻辑的技术

.. note:: 

   从纯技术的视角来看，并不是严格需要装饰器:它们的功 能往往可以使用简单的辅助函数调用或其它的技术来实现

1.2 管理调用和实例
~~~~~~~~~~~~~~~~~~~~~~~~

装饰器通过自动把函数和类名重绑定到其他的可调用对象来实现这些效果，在 def 和 class 语句的末尾做到这点。
当随后调用的时候，这些可调用对象可以执行诸如对函数调用跟踪和计时、管理对类实例属性的访问等任务。

   - 函数装饰器安装包装器对象，以在需要的时候拦截随后的 **函数调用并** 处理它们

   - 类装饰器安装包装器对象，以在需要的时候拦截随后的 **实例创建调用** 并处理它们

1.3 管理函数和类
~~~~~~~~~~~~~~~~~~~~~~~~

尽管大多数实例都使用包装器来拦截随后对函数和类的调用，但这并非使用装饰器的唯一方法:

   - 函数装饰器: 也可以用来管理函数对象，而不是随后对它们的调用
   
      - 例如，把一个函数注册到一个 API
   
   - 类装饰器: 也可以用来直接管理类对象，而不是实例创建调用
   
      - 例如，用新的方法扩展类

换句话说，函数装饰器可以用来管理函数调用和函数对象，类装饰器可以用来管理类实 例和类自身。通过返回装饰的对象自身而不是一个包装器，装饰器变成了针对函数和类 的一种简单的后创建步骤。

1.4 使用和定义装饰器
~~~~~~~~~~~~~~~~~~~~~~~~

Python 本身带有具有特定角色的内置装饰器——静态方法装饰器、属性装饰器以及更多。
此外，很多流行的 Python 工具包括了执行管理数据库或用户接口逻辑等任务的装饰器。
在这样的情况中，我们不需要知道装饰器如何编码就可以完成任务。

对于更为通用的任务，程序员可以编写自己的任意装饰器。例如，函数装饰器可能实现下面的功能代码来扩展函数:

   - 通过添加跟踪调用

   - 在调试时执行参数验证测试
   
   - 自动获取和释放线程锁
   
   - 统计调用函数的次数以进行优化

你可以想象添加到函数调用中的任何行为，都可以作为定制函数装饰器的备选。

另外一方面，函数装饰器设计用来只增强一个特定函数或方法调用，而不是一个完整的对象接口。
类装饰器更好地充当后一种角色——因为它们可以拦截实例创建调用，它们可以用来实现任意的对象接口扩展或管理任务。
例如，定制的类装饰器可以跟踪或验证对一个对象的每个属性引用。它们也可以用来实现代理对象、
单体类以及其他常用的编程模式。实际上，我们将会发现很多类装饰器与在第30章中见到的委托编程模式有很大的相似之处。

2.装饰器基础知识
-------------------

.. important:: 

   装饰器的很多神奇之处可归结为自动绑定操作

2.1 函数装饰器
~~~~~~~~~~~~~~~~~~~~~~~~

函数装饰器主要只是一种语法糖: 通过在一个函数的 def 语句的末尾来运行另一个函数，把最初的函数名重新绑定到结果.

2.1.1 用法
^^^^^^^^^^^^^^^^^^^^^^^

函数装饰器是一种关于函数的运行时声明，函数的定义需要遵守此声明。
装饰器在紧挨着定义一个函数或方法的 def 语句之前的一行编写，
并且它由 ``@`` 符号以及紧随其后的对于元函数的一个引用组成——
这是管理另一个函数的函数(或其他的可调用对象)。

在编码方面，函数装饰器自动将如下的语法：

.. code-block:: python

   @decorator
   def F(arg):
      ...
   
   F(99)

映射为这一对等的形式，其中装饰器是一个单参数的可调用对象，
它返回与 F 具有相同数目的参数的一个可调用对象：

.. code-block:: python

   def F(arg):
      ...

   F = decorator(F)
   F(99)

这一自动名称重绑定在 def 语句上有效，不管它针对一个简单的函数或是类中的一个方法。
当随后调用 F 函数的时候，它自动调用装饰器所返回的对象，该对象可能是实现了所需的包装逻辑的另一个对象，
或者是最初的函数本身。


示例 1 装饰实际把如下的第一行映射为第二行：

.. code-block:: python

   func(6, 7)
   decorator(func)(6, 7)

实例 2 在 def 语句的末尾，方法名重新绑定到一个内置函数装饰器的结果，随后再调用最初的名称，将会调用装饰器所返回的对象：

.. code-block:: python

   class C:

      @staticmethod
      def meth(*args):     # meth = staticmethod(meth)
         pass
   
   class C:
      @property
      def name(self): # name = property(name)
         ...

2.1.2 实现
^^^^^^^^^^^^^^^^^^^^^^^








2.1.3 支持方法装饰
^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: python

   class decorator:
      def __init__(self, func):
         self.func = func
      def __call__(self, *args):
         # self.func(*args) fails! # C instance not in ars!
   
   class C:
   
      @decorator
      def method(self, x, y):
         ...




.. code-block:: python

   def decorator(F):
      def wrapper(*args):
         # F(*args) runs func or method
      
      return wrapper
   
   @decorator
   def func(x, y):
      ...
   func(6, 7)

   class C:
      @decorator
      def method(self, x, y):
         ...
   
   X = C()
   X.method(6, 7)





2.2 类装饰器
~~~~~~~~~~~~~~~~~~~~~~~~

类装饰器与函数装饰器密切相关，实际上，它们使用相同的语法和非常相似的编码模式。
然而，不是包装单个的函数或方法，类装饰器是管理类的一种方式，
或者用管理或扩展类所创建的实例的额外逻辑，来包装实例构建调用。

2.2.1 用法
^^^^^^^^^^^^^^^^^^^^^^^

从语法上讲，类装饰器就像前面的 class 语句一样(就像前面函数定义中出现的函数装饰器)。
在语法上，假设装饰器是返回一个可调用对象的一个单参数的函数，类装饰器语法：

.. code-block:: python

   # Decorate class
   @decorator
   class C:
      ...
   
   # Make an instance 
   x = C(99)

类自动地传递给装饰器函数，并且装饰器的结果返回来分配给类名, 
直接的结果就是，随后调用类名会创建一个实例，
该实例会触发装饰器所返回的可调用对象，而不是调用最初的类本身：

.. code-block:: python

   class C:
      ...
   C = decorator(C)

   # Essentially calls decorator(C)(99)
   x = C(99)


2.2.2 实现
^^^^^^^^^^^^^^^^^^^^^^^

新的类装饰器使用函数装饰器所使用的众多相同的技术来编码。
由于类装饰器也是返回一个可调用对象的一个可调用对象，
因此大多数函数和类的组合已经最够了。


.. code-block:: python

   def decorator(C):
      # Process class C
      return C

   # C = decorator(C)
   @decorator
   class C:
      ...


.. code-block:: python

   def decorator(C):
      # Save or Use class C
      # Return a different callable: nested def, class with __call__, etc.

   # C = decorator(C)
   @decorator
   class C:
      ...

.. code-block:: python

   def decorator(cls):
      class Wrapper:
         def __init__(self, *args):
            self.wrapped = cls(*args)
         def __getattr__(self, name):
            return getattr(self.wrapped, name)
      
      return Wrapper
   
   @decorator
   class C:
      def __init__(self, x, y):
         self.attr = "spam"
   
   x = C(6, 7)
   print(x.attr)


2.2.3 支持多个实例
^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: python

   class Decorator:
      def __init__(self, C):
         self.C = C
      def __call__(self, *args):
         self.wrapped = self.C(*args)
         return self
      def __getattr__(self, attrname):
         return getattr(self.wrapper, attrname)
   
   @Decorate
   class C:
      ...
   
   x = C()
   y = C()



2.3 装饰器参数
~~~~~~~~~~~~~~~~~~~~~~~~

2.4 装饰器管理函数和类
~~~~~~~~~~~~~~~~~~~~~~~~

3.编写函数装饰器
-------------------

3.1 跟踪调用
~~~~~~~~~~~~~~~~~~~~~~~



3.2 状态信息保持选项
~~~~~~~~~~~~~~~~~~~~~~~
















4.编写类装饰器
-------------------

4.1 单体类
~~~~~~~~~~~~~~~~~~~~


4.2 跟踪对象接口
~~~~~~~~~~~~~~~~~~~~







5.直接管理函数和类
-------------------




6.示例
-------------------